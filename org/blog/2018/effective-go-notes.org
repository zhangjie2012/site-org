#+SETUPFILE: ~/site/tpl/site-tpl.org
#+TITLE: Effective Go 精简版
#+DATE: 2018-08-03 14:11:00

花了一段时间看完了官方的
[[https://golang.org/doc/effective_go.html][Effective Go]]
文档，今天又把 [[https://go-zh.org/doc/effective_go.html][中文翻译]]
的过了一遍。

对于 Effective 系列的书，我还是停留在五六年前看过的
[[https://book.douban.com/subject/1842426/][Effective
C++]]、[[https://book.douban.com/subject/1457891/][More Effective C++]]
和 [[https://book.douban.com/subject/1792179/][Effective
STL]]，其内容深层次的剖析的 C++
语言中的众多核心特性（指针、内存分配、面向对象、泛型编程等），看完之后让人茅塞顿开、叹息不已。

然而带着对 Go 语言的疑惑（指针、内存模型、并发等）来看 Effective
Go，并没有得到我想要的东西，对于深层次的东西都是一带而过的，有些失望，可能是
Go 语言本身并没有 C++ 那么复杂，也可能是我预期太高了一些。

总体来看 Effective Go 比较基础，可作为 Go 入门之后的第二本书（而
Effective C++ 没有一定的 C++
基础不建议阅读，也看不懂），更像是一个如何更好些 Go 语言的语言规范。

作为一个 C/C++ 出身的程序员，这篇文章主要整理了在写 Go
程序过程中可能会迷惑的、出问题地方（基于 Effective Go）。

--------------

** 引言
   :PROPERTIES:
   :CUSTOM_ID: 引言
   :END:

Go
是一门全新的语言，尽管它借鉴了很多已有语言的许多理念，但它有自己的语言特性。虽然你也可以用写
C++ 或者 Java 的方式来写 Go 语言，但程序可能不能令人满意。所以想要把 Go
程序写好了，需要了解它的特性、风格，即以 Go 的方式来思考
Go，才能写出更好的 Go 程序。

** 格式化
   :PROPERTIES:
   :CUSTOM_ID: 格式化
   :END:

Go 提供了 gofmt
工具来按照标准来格式化代码，尝试解决同一种语言编码风格混乱的问题，所有人都遵循相同的风格，也不用在编码风格上再浪费时间。

** 注释
   :PROPERTIES:
   :CUSTOM_ID: 注释
   :END:

Go 语言支持 C 风格的注释 =/**/= 和 =//= ，块注释一般用于给包做注释。

*包注释* 一般放于包子句 =package xxx=
的前面，包含多个包文件的包，包注释放于任意一个文件中即可。

在包中，顶级声明前面的注释称作该声明的*文档注释*，程序中，每个导出的名称（首字母大写）都应该有文档注释。第一句应当以被声明的东西开头（以便查找文档），并且是一个完整的句子作为摘要。

同样，Go 提供了 godoc 用来提取工程中的文档。

** 命名
   :PROPERTIES:
   :CUSTOM_ID: 命名
   :END:

*** 包命名
    :PROPERTIES:
    :CUSTOM_ID: 包命名
    :END:

包的名字应该简洁明了，易于理解：

- 使用小写的单个单词来命名，不使用下划线或驼峰记法
- 不需要保证在所有源码中保持唯一（导入时需要使用包的全路径），即便是同一个源文件中出现了两个相同的包名，也可以使用别名的方式解决冲突
- 使用包的内容，一般通过包名来引用（可避免命名冲突）

*** Getter、Setter 命名
    :PROPERTIES:
    :CUSTOM_ID: gettersetter-命名
    :END:

Go 不在语言层面提供 getter 和 setter 的支持，你可以自己做封装。通常
getter 直接用变量名命名（首字母大写），而不是 =GetXxx=，setter 使用
=SetXxx=。

*** 接口命名
    :PROPERTIES:
    :CUSTOM_ID: 接口命名
    :END:

如果只有一个方法的接口，应该在该方法的名称加上 -er 后缀来命名，比如
Reader、Writer。

*** 驼峰命名
    :PROPERTIES:
    :CUSTOM_ID: 驼峰命名
    :END:

Go 使用驼峰的方式来命名，MinxedCaps 或者 mixedCaps。

** 分号
   :PROPERTIES:
   :CUSTOM_ID: 分号
   :END:

Go 语言和 C 一样，已分号作为语句的结尾，但与 C
不同的是，分号并不会在源码中出现，Go
的词法分析器会根据规则自动插入分号。也因为这样代码块 ={}= 中的前一个 ={=
放在上一行的结尾（如果放在下一行，Go
会在上一行自动加上分号），还有多值分行初始化时，最后一行同样要添加一个逗号。

** 控制结构
   :PROPERTIES:
   :CUSTOM_ID: 控制结构
   :END:

- Go 没有 while 循环，只有通用的 for 循环（可以满足 while 的需求）
- if、switch、for
  支持一个可选的初始化语句，常见的用法：=if _, err := func(); err != nil=
- Go 没有逗号操作符，所以可以使用平行复制的方式 =i, j = j, i=
- =++= 和 =--= 是语句*而非*表达式

*** Switch
    :PROPERTIES:
    :CUSTOM_ID: switch
    :END:

Go 中的 switch 比 C 更通用（而且解决 C 的很多潜在问题）：

- switch 表达式无需常量或者整数
- case 语句会逐一进行求值直到匹配为止（C 并不是这样，C
  是找到一个匹配的入口，如果没遇到 break 则会一直往下执行，不管下面的
  case 条件是否满足）
- if-else-if-else 可以使用 switch 替换
- Go 的 break 可以指定一个可选的 Label（类似 C 中的 goto 语句，但是 C
  中的 goto 可能会导致资源泄露，所以一般不用）
- switch 配合类型断言语法，可做类型选择

** 函数
   :PROPERTIES:
   :CUSTOM_ID: 函数
   :END:

- Go 支持多值返回，通常第二个值表示错误码
- 返回值可添加命名形参，在函数开始执行时初始化为零值，有命名形参时，返回时
  return 空即可
- =defer= 语法可以让函数延迟到代码块结束时调用，一般用来释放资源：

  - 被延迟调用的函数参数是立即计算值，而不是调用时
  - Deferred 函数式后入先出的执行顺序（LIFO）

** 数据
   :PROPERTIES:
   :CUSTOM_ID: 数据
   :END:

Go 有两种内置的内存分配原语：=new= 和 =make=。

- =new=
  跟其它编程语言不同的地方在于它申请的内存不会被_初始化_，它只是全部设置为_零值_（译者：文档有点歧义，实际上
  Go 的 new
  是会初始化内存的，只不过初始化成了对应类型的零值，这里表达的应该是类似
  C++ 中的 new 会自动调用构造函数）。返回的是 T*
- =make(T, args)= 和 =new(T)= 有不同的设计目标，make 只用来创建
  slices、maps 和 channels，并且返回的是_初始化_的（非零值）的类型
  T（而不是*T），原因是这三种类型在后台实现时必须进行初始化。比如：切片实际包含三个字段：指向数据的指针、长度和容量，在初始化这些数据之前
  slice 是 =nil=。对于 slices、maps 和 channels，make
  会初始化其内部结构数据。

*注意*：=make= 只能用于 slices、maps 和 channels
并且返回的是对象，而不是指针。

*** 数组
    :PROPERTIES:
    :CUSTOM_ID: 数组
    :END:

Go 的数组与 C 不同点：

- 数组是值，赋值时会把所有的数据拷贝一份
- 如果把数组传递给函数，函数拿到的是数组的 copy ，而不是指针
- 数组的大小是类型的一部分。=[10]int= 和 =[20]int=
  是不同的（可参考[[/in-c-arrays-why-is-this-true-a5-5a.html][这篇文章]]）

如果你想要和 C 一样传递数组给函数，你需要使用数组的指针，但通常使用
slice 来代替 array。

*** 切片
    :PROPERTIES:
    :CUSTOM_ID: 切片
    :END:

请查看我之前写的 [[file:understand-go-array-and-slice.html][理解 Go 的
Array 和 slice]]。

*** 映射（Map）
    :PROPERTIES:
    :CUSTOM_ID: 映射map
    :END:

- 将 map 传递给函数，在函数内部修改 map 会修改调用方的 map

- 访问一个 key 不存在的值，会返回 value 类型的零值（所以 set 可以使用
  value 类型为 bool 来实现，不存在时值为
  false）；当需要程序上判断一个值是否存在时，可以通过访问时返回的第二个值来判断，如下：

  #+BEGIN_EXAMPLE
      func offset(tz string) int {
          if seconds, ok := timeZone[tz]; ok {
              return seconds
          }
          log.Println("unknown time zone:", tz)
          return 0
      }
  #+END_EXAMPLE

- 删除 map 中的某个 key 使用内置的 =delete= 函数，即便 key
  已经已经被删掉了，再执行一次也是安全的

*** 初始化
    :PROPERTIES:
    :CUSTOM_ID: 初始化
    :END:

- 常量：在 Go
  中常量仅仅值的是不变的值。他们由编译期间创建，可以为数字、字符、字符串或者布尔类型，因为编译期间的限制，表达式必须是常量表达式，由编译器来计算值（函数调用是运行时）
- init 函数：每个源文件都可以定义自己的 =init=
  函数，而且可以有多个。=init=
  函数即不接受参数也不返回任何值，而且不能被主动调用，在包导入时会自动调用执行，在
  =main= 函数之前执行。=init=
  最常见的用法是用来完成初始化表达式未能完成的初始化工作，还可用作状态检查与修复、注册、只被执行一次的运算等

** 方法
   :PROPERTIES:
   :CUSTOM_ID: 方法
   :END:

*** 指针 vs 值
    :PROPERTIES:
    :CUSTOM_ID: 指针-vs-值
    :END:

对于指针和值接收器调用原则为：值接收器关联的函数可以被指针和值调用，而指针方法只能被指针调用。语言为了避免这种错误，就添加了一个例外，当值是有地址的时候，出现值调用指针方法的时候，语言会自动插入地址运算。（换句话说，都可以相互调用，只不过区别在于是否修改调用方的值）

** 接口
   :PROPERTIES:
   :CUSTOM_ID: 接口
   :END:

- Go
  中的接口和实现不像其它语言一样，没有显式的关联关系，它只是定义了一个规范，谁有它的*行为*，谁就是它
- 如果一个类型仅仅实现了一个接口，并且除此之外没有其它需要导出的方法，那这个类型也不需要导出（在这种情况下构造函数返回一个接口值，而非类型），这其实是一种很好的抽象（关注行为，而非数据）。

** 空白标识符
   :PROPERTIES:
   :CUSTOM_ID: 空白标识符
   :END:

- 空白标识符可被赋予或声明为任何类型的任何值，而其值会被无害地丢弃，类似
  Unix 中的 =/dev/null= 文件，只写不读
- 导入包时，别名设置为空白标识符，可解决需要使用导入包的 init
  ，但本文件又不需要包内容的情况（Go 不允许导入不使用的包）

** 内嵌
   :PROPERTIES:
   :CUSTOM_ID: 内嵌
   :END:

Go
语言不提供类型子类这样的东西，但是它提供了在接口或者结构体中内嵌的接口或结构体的方法。

内嵌的接口和结构体可以接口/结构体名称直接访问，如果想要直接访问时字段名为类型名。比如：

#+BEGIN_EXAMPLE
  type Job struct {
      Command string
      *log.Logger
  }
#+END_EXAMPLE

访问 log.Logger 的成员可以直接通过 Job
的对象来访问，当然也可以用显示调用的方式来访问：=job.Logger.Logf=，访问忽略包名（log）即可。

内嵌引来的问题是名称冲突，解决规则很简单：

- 首先，上层的字段会覆盖到深层的字段
- 其次，如果在相同级别上出现了两个名字相同的字段（这样通常是错误的），但如果内部不使用的情况下，不会出问题

笔者：尽可能用组合代替继承。

** 并发
   :PROPERTIES:
   :CUSTOM_ID: 并发
   :END:

*** Goroutines
    :PROPERTIES:
    :CUSTOM_ID: goroutines
    :END:

- goroutines
  是并发运行在同一地址空间的函数，比线程更轻量级（消耗只有栈空间的分配）
- 在多线程操作系统上实现多路复用，如果一个线程阻塞（比如等待
  I/O），就会在其它线程上运行（隐藏了线程创建和管理的复杂性，本质上底层是线程调度的）

*** 管道（Channels）
    :PROPERTIES:
    :CUSTOM_ID: 管道channels
    :END:

管道和 maps 类似，使用 =make=
分配，返回一个底层数据结构的引用。可以提供一个可选的整型参数，用来设置管道的大小。默认值是
0，作为无缓冲或者同步管道。

** 错误
   :PROPERTIES:
   :CUSTOM_ID: 错误
   :END:

*** Panic
    :PROPERTIES:
    :CUSTOM_ID: panic
    :END:

通常情况下，出错的时候应该向调用者返回一个 =error=，比如 Read
方法会返回字节数量和
error。但是有时候会遇到错误无法恢复，程序无法正常运行的情况。

Go 提供了内建函数 =panic=
用来创建一个运行时的错误将停止程序的运行，它有一个任意类型的参数（经常是个
string
在程序快挂的时候输出），一般用来表示处理逻辑上不可能发生的事情，比如无限循环竟然退出了：

#+BEGIN_EXAMPLE
  // A toy implementation of cube root using Newton's method.
  func CubeRoot(x float64) float64 {
      z := x/3   // Arbitrary initial value
      for i := 0; i < 1e6; i++ {
          prevz := z
          z -= (z*z*z-x) / (3*z*z)
          if veryClose(z, prevz) {
              return z
          }
      }
      // A million iterations has not converged; something is wrong.
      panic(fmt.Sprintf("CubeRoot(%g) did not converge", x))
  }
#+END_EXAMPLE

一般情况下库函数应该避免使用 =panic=
。如果程序出现了问题，应该尽可能的自愈然后继续运行。

*** Recover
    :PROPERTIES:
    :CUSTOM_ID: recover
    :END:

当 =panic=
调用时，包含隐式的运行时错误，比如越界访问，断言失败等，它会立即停止运行然后展开
goroutine 的堆栈，接下来运行 defer 函数。但是可以通过 =recover= 重新获得
goroutine 的控制并恢复正常运行。代码只能放在 defer 函数中（只有 defer
函数在这个时候才能正常运行）。

recover 只会关闭当前的 goroutine（干净的退出），而不会影响其它正在执行的
goroutines。
